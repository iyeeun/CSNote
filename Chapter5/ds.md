<br>

# Chapter 5. 자료 구조

## 0. 자료구조
: 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터셋
<br>

## 1. 복잡도
### 1.1 시간 복잡도
- 시간 복잡도 : 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계, 실행 시간에 대한 효율성을 평가하는 척도
    
    #### Big-O Notation
    : 입력 범위 n을 기준으로 로직이 몇 번 반복되는지 가장 영향을 많이 끼치는 항, 즉 **최고차항의 지수**로만 나타냄 (계수, 나머지항 무시)

### 1.2 공간 복잡도
- 공간 복잡도 : 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

### 1.3 자료 구조에서의 시간 복잡도
#### 평균 시간 복잡도
|자료 구조|접근|탐색|삽입|삭제|
|:---:|:---:|:---:|:---:|:---:|
|array|O(1)|O(n)|O(n)|O(n)|
|stack|O(n)|O(n)|O(1)|O(1)|
|queue|O(n)|O(n)|O(1)|O(1)|
|doubly linked list|O(n)|O(n)|O(1)|O(1)|
|hash table|O(1)|O(1)|O(1)|O(1)|
|BST|O(logn)|O(logn)|O(logn)|O(logn)|
|AVL tree|O(logn)|O(logn)|O(logn)|O(logn)|
|RB tree|O(logn)|O(logn)|O(logn)|O(logn)|

<br>

#### 최악 시간 복잡도
|자료 구조|접근|탐색|삽입|삭제|
|:---:|:---:|:---:|:---:|:---:|
|array|O(1)|O(n)|O(n)|O(n)|
|stack|O(n)|O(n)|O(1)|O(1)|
|queue|O(n)|O(n)|O(1)|O(1)|
|doubly linked list|O(n)|O(n)|O(1)|O(1)|
|**hash table**|O(n)|O(n)|O(n)|O(n)|
|**BST**|O(n)|O(n)|O(n)|O(n)|
|**AVL tree**|O(logn)|O(logn)|O(logn)|O(logn)|
|**RB tree**|O(logn)|O(logn)|O(logn)|O(logn)|

<br>

## 2. 선형 자료 구조
: 요소가 일렬로 나열되어 있는 자료 구조

### 2.1 연결 리스트 (Linked list)
- 연결 리스트 : 노드를 포인터로 연결
    - 싱글 연결 리스트 : next
    - 이중 연결 리스트 : next, prev
    - 원형 이중 연결 리스트 : next, prev + 마지막 노드의 next -> head

### 2.2 배열 (Array)
- 배열 (정적) : 아래의 성질을 만족하는 변수들을 모아놓은 집합
    1. 같은 타입의 변수들로 이루어져 있음
    2. 크기가 정해져 있음
    3. 인접한 메모리 위치에 있음
    4. 중복을 허용하고 순서가 있음

#### 랜덤 접근과 순차적 접근
- 랜덤 접근 : == 직접 접근, 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능 -> O(1)
- 순차적 접근 : 저장된 순서대로 접근해야 함 -> O(N)

#### 배열과 연결 리스트 비교
- 탐색 : 배열 > 연결 리스트
- 데이터 추가 및 삭제 : 배열 < 연결 리스트

### 2.3 벡터 (Vector)
- 벡터 : 동적으로 요소를 할당할 수 있는 동적 배열
    - 중복을 허용하고 순서가 있고 랜덤 접근이 가능
    - 2의 제곱승 + 1마다 크기를 2배로 늘림
    - 연산 시간
        - push_back : O(1)
        - 그 외의 삽입 : O(N)
        - 탐색 : O(1)

### 2.4 스택 (Stack)
- 스택 : 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 구조
    - 예시 : 재귀, 웹 방문 기록
    - 연산 시간
        - 삽입 및 삭제 : O(1)
        - 탐색 : O(N)

### 2.5 큐 (Queue)
- 스택 : 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 구조
    - 예시 : 프로세스, 네트워크 행렬, 캐시
    - 연산 시간
        - 삽입 및 삭제 : O(1)
        - 탐색 : O(N)

<br>

## 3. 비선형 자료 구조
: 자료 순서나 관계가 복잡한 구조

### 3.1 그래프 (Graph)
- 그래프 : 정점(vertex)과 간선(edge)으로 이루어진 자료 구조
    - 방향성에 따라 : 단방향/양방향
        - 들어오는/나가는 간선 : indegree/outdegree

### 3.2 트리 (Tree)
- 트리 : 그래프 중 한 형태로 계층적 데이터의 집합
    - 구성 : 루트, 내부, 리프 노드
    - 특징
        1. 부모, 자식 계층 구조를 가짐
        2. V - 1 = E
        3. 한 노드에서 다른 노드까지의 경로는 하나
    - 높이와 레벨
        - 높이 : 루트부터 리프까지의 거리 중 가장 긴 거리 (edge 수로 계산)
        - 깊이 (레벨) : 루트부터 특정 노드까지의 최단 거리 (edge 수로 계산)
    - 서브트리 : 트리 내에 있는 부분 집합

#### 이진 트리 (Binary Tree)
: 자식의 노드 수가 두 개 이하인 트리
- 종류
    - 정이진 트리 (Full binary tree) : 자식 노드가 0 or 2
    - 완전 이진 트리 (Complete binary tree) : 왼쪽에서부터 채워짐. (internal node가 모두 자식 2, leaf는 왼쪽부터)
    - 변질 이진 트리 (Degenerate binary tree) : 자식 노드가 0 or 1
    - 포화 이진 트리 (Perfect binary tree) : 모든 노드가 꽉 차 있음
    - 균형 이진 트리 (Balanced binary tree) : 왼쪽과 오른쪽의 높이 차이가 1 이하

#### 이진 탐색 트리 (Binary Search Tree)
: 노드의 오른쪽에는 큰 값만, 왼쪽에는 작은 값만 -> 탐색 시간이 평균 O(logN)이지만 최악의 경우 선형적일 수 있기 때문에 O(N)

#### AVL 트리
: self-balanced tree, 두 자식 서브트리의 높이는 항상 최대 1만큼 차이남 <br>
탐색, 삽입, 삭제 모두 O(logN)
삽입 및 삭제 후에 트리 일부를 회전시켜 균형을 잡음

#### 레드 블랙 트리 (RB Tree)
: 균형 이진 탐색 트리, 탐색/삽입/삭제 모두 O(logN) <br>
각 노드는 R or B의 색상 정보를 가짐 <br>
**모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 자식은 블랙**이라는 규칙

### 3.3 힙 (Heap)
- 힙 : 완전 이진 트리 기반의 자료 구조, minheap과 maxheap이 있음